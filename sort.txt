1,要实现堆排序，有2个步骤
 1)把数组数据堆化 build_heap
 2)交换第一个元素和最后一个元素，然后heapify 第一个元素；不断重复这2个操作，这样操作一遍后，你的数组自然第一个元素就是最小的元素了。
我的总结：核心思路就是把从倒处第一个数开始的数和第一个数交换，每一次都heapfy使得最大的数到堆顶。
2,堆的特点
 堆顶元素大于子节点元素

3,heapfy 的功能就是把最大的数放到堆顶，只负责把根节点放到堆顶
 build_heap 就是把堆中的每一个父节点都大于子节点
4,堆排序和冒泡排序的比较有什么区别和联系？？？
 冒泡排序是把最大的节点放到最后，堆排序也是；
 堆排序是把根节点放到最后，依次这样；
 冒泡排序是通过n次排序依次把最大的数浮到最后。
5,build_heap 的设计思路？？？
 根据父节点和子节点的关系 parent = (last_node - 1)/2;在for循环中利用heapfy 循环N次(数组的长度)
6,heapfy 的设计思路？？？
把数组中的数都放到一个堆上面，按照从左到右，从上到下的顺序。
把二叉树和冒泡排序的思路结合就是堆排序======这个是堆排序的核心思路

0，堆排序的核心是什么？？？是完全二叉树
 深度为k,且有2^k-1个节点的二叉树是完全二叉树

完全二叉树的3个特点：
1，每一层的节点数总是最大节点数

2，满二叉树的所有节点都有左右子树

3，可对满二叉树的所有节点进行连续编号，若规定从根节点开始，从左到右，从上到下的原则进行.

完全二叉树的定义和特点
